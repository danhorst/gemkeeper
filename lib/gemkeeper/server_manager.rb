# frozen_string_literal: true

require "open3"
require "fileutils"

module Gemkeeper
  class ServerManager
    attr_reader :config

    def initialize(config)
      @config = config
    end

    def start
      raise ServerAlreadyRunningError, "Server is already running (PID: #{read_pid})" if running?

      generate_config_ru
      start_server
    end

    def start_foreground
      raise ServerAlreadyRunningError, "Server is already running (PID: #{read_pid})" if running?

      generate_config_ru
      start_server_foreground
    end

    def stop
      raise ServerNotRunningError, "Server is not running" unless running?

      pid = read_pid
      Process.kill("TERM", pid)

      # Wait for process to stop
      10.times do
        break unless process_alive?(pid)

        sleep 0.5
      end

      # Force kill if still running
      Process.kill("KILL", pid) if process_alive?(pid)

      cleanup_pid_file
      true
    rescue Errno::ESRCH
      # Process already dead
      cleanup_pid_file
      true
    end

    def status
      if running?
        { running: true, pid: read_pid, url: config.geminabox_url }
      else
        { running: false }
      end
    end

    def running?
      return false unless File.exist?(config.pid_file)

      pid = read_pid
      return false unless pid

      process_alive?(pid)
    end

    private

    def generate_config_ru
      FileUtils.mkdir_p(config.cache_dir)
      FileUtils.mkdir_p(config.gems_path)

      content = <<~RUBY
        # frozen_string_literal: true
        # Auto-generated by Gemkeeper

        require "rubygems/indexer"
        require "geminabox"

        Geminabox.data = #{config.gems_path.inspect}
        Geminabox.rubygems_proxy = true

        run Geminabox::Server
      RUBY

      File.write(config.config_ru_path, content)
    end

    def start_server
      cmd = [
        "rackup",
        config.config_ru_path,
        "-p", config.port.to_s,
        "-D",
        "-P", config.pid_file,
        "-s", "puma"
      ]

      Dir.chdir(config.cache_dir) do
        _stdout, stderr, status = Open3.capture3(*cmd)

        raise ServerError, "Failed to start server:\n#{stderr}" unless status.success? || File.exist?(config.pid_file)
      end

      # Wait for server to be ready
      wait_for_server
    end

    def start_server_foreground
      cmd = [
        "rackup",
        config.config_ru_path,
        "-p", config.port.to_s,
        "-s", "puma"
      ]

      Dir.chdir(config.cache_dir) do
        system(*cmd)
      end
    end

    def wait_for_server(timeout: 10)
      require "net/http"

      deadline = Time.now + timeout
      uri = URI(config.geminabox_url)

      while Time.now < deadline
        begin
          response = Net::HTTP.get_response(uri)
          return true if response.is_a?(Net::HTTPSuccess) || response.is_a?(Net::HTTPRedirection)
        rescue Errno::ECONNREFUSED, Errno::ECONNRESET, SocketError
          # Server not ready yet
        end
        sleep 0.5
      end

      raise ServerError, "Server failed to start within #{timeout} seconds"
    end

    def read_pid
      return nil unless File.exist?(config.pid_file)

      pid = File.read(config.pid_file).strip.to_i
      pid.positive? ? pid : nil
    end

    def process_alive?(pid)
      Process.kill(0, pid)
      true
    rescue Errno::ESRCH, Errno::EPERM
      false
    end

    def cleanup_pid_file
      FileUtils.rm_f(config.pid_file)
    end
  end
end
